{
  "version": 3,
  "sources": ["assets/js/instant.page.src.js"],
  "sourcesContent": ["/*! instant.page v5.2.0 - (C) 2019-2024 Alexandre Dieulot - https://instant.page/license */\n\nlet _chromiumMajorVersionInUserAgent = null,\n\t_speculationRulesType,\n\t_allowQueryString,\n\t_allowExternalLinks,\n\t_useWhitelist,\n\t_delayOnHover = 65,\n\t_lastTouchstartEvent,\n\t_mouseoverTimer,\n\t_preloadedList = new Set();\n\ninit();\n\nfunction init() {\n\tconst supportCheckRelList = document.createElement('link').relList;\n\tconst isSupported =\n\t\tsupportCheckRelList.supports('prefetch') &&\n\t\tsupportCheckRelList.supports('modulepreload');\n\t// instant.page is meant to be loaded with <script type=module>\n\t// (though sometimes webmasters load it as a regular script).\n\t// So it\u2019s normally executed (and must not cause JavaScript errors) in:\n\t// - Chromium 61+\n\t// - Gecko in Firefox 60+\n\t// - WebKit in Safari 10.1+ (iOS 10.3+, macOS 10.10+)\n\t//\n\t// The check above used to check for IntersectionObserverEntry.isIntersecting\n\t// but module scripts support implies this compatibility \u2014 except in Safari\n\t// 10.1\u201312.0, but this prefetch check takes care of it.\n\t//\n\t// The modulepreload check is used to drop support for Firefox < 115 in order\n\t// to lessen maintenance.\n\t// This implies Safari 17+ (if it supported prefetch), if we ever support\n\t// fetch()-based preloading for Safari we might want to OR that check with\n\t// something that Safari 15.4 or 16.4 supports.\n\t// Also implies Chromium 66+.\n\n\tif (!isSupported) {\n\t\treturn;\n\t}\n\n\tconst handleVaryAcceptHeader =\n\t\t'instantVaryAccept' in document.body.dataset || 'Shopify' in window;\n\t// The `Vary: Accept` header when received in Chromium 79\u2013109 makes prefetches\n\t// unusable, as Chromium used to send a different `Accept` header.\n\t// It\u2019s applied on all Shopify sites by default, as Shopify is very popular\n\t// and is the main source of this problem.\n\t// `window.Shopify` only exists on \u201Cclassic\u201D Shopify sites. Those using\n\t// Hydrogen (Remix SPA) aren\u2019t concerned.\n\n\tconst chromiumUserAgentIndex = navigator.userAgent.indexOf('Chrome/');\n\tif (chromiumUserAgentIndex > -1) {\n\t\t_chromiumMajorVersionInUserAgent = parseInt(\n\t\t\tnavigator.userAgent.substring(\n\t\t\t\tchromiumUserAgentIndex + 'Chrome/'.length\n\t\t\t)\n\t\t);\n\t}\n\t// The user agent client hints API is a theoretically more reliable way to\n\t// get Chromium\u2019s version\u2026 but it\u2019s not available in Samsung Internet 20.\n\t// It also requires a secure context, which would make debugging harder,\n\t// and is only available in recent Chromium versions.\n\t// In practice, Chromium browsers never shy from announcing \"Chrome\" in\n\t// their regular user agent string, as that maximizes their compatibility.\n\n\tif (\n\t\thandleVaryAcceptHeader &&\n\t\t_chromiumMajorVersionInUserAgent &&\n\t\t_chromiumMajorVersionInUserAgent < 110\n\t) {\n\t\treturn;\n\t}\n\n\t_speculationRulesType = 'none';\n\tif (\n\t\tHTMLScriptElement.supports &&\n\t\tHTMLScriptElement.supports('speculationrules')\n\t) {\n\t\tconst speculationRulesConfig = document.body.dataset.instantSpecrules;\n\t\tif (speculationRulesConfig == 'prerender') {\n\t\t\t_speculationRulesType = 'prerender';\n\t\t} else if (speculationRulesConfig != 'no') {\n\t\t\t_speculationRulesType = 'prefetch';\n\t\t}\n\t}\n\n\tconst useMousedownShortcut =\n\t\t'instantMousedownShortcut' in document.body.dataset;\n\t_allowQueryString = 'instantAllowQueryString' in document.body.dataset;\n\t_allowExternalLinks = 'instantAllowExternalLinks' in document.body.dataset;\n\t_useWhitelist = 'instantWhitelist' in document.body.dataset;\n\n\tlet preloadOnMousedown = false;\n\tlet preloadOnlyOnMousedown = false;\n\tlet preloadWhenVisible = false;\n\tif ('instantIntensity' in document.body.dataset) {\n\t\tconst intensityParameter = document.body.dataset.instantIntensity;\n\n\t\tif (intensityParameter == 'mousedown' && !useMousedownShortcut) {\n\t\t\tpreloadOnMousedown = true;\n\t\t}\n\n\t\tif (intensityParameter == 'mousedown-only' && !useMousedownShortcut) {\n\t\t\tpreloadOnMousedown = true;\n\t\t\tpreloadOnlyOnMousedown = true;\n\t\t}\n\n\t\tif (intensityParameter == 'viewport') {\n\t\t\tconst isOnSmallScreen =\n\t\t\t\tdocument.documentElement.clientWidth *\n\t\t\t\t\tdocument.documentElement.clientHeight <\n\t\t\t\t450000;\n\t\t\t// Smartphones are the most likely to have a slow connection, and\n\t\t\t// their small screen size limits the number of links (and thus\n\t\t\t// server load).\n\t\t\t//\n\t\t\t// Foldable phones (being expensive as of 2023), tablets and PCs\n\t\t\t// generally have a decent connection, and a big screen displaying\n\t\t\t// more links that would put more load on the server.\n\t\t\t//\n\t\t\t// iPhone 14 Pro Max (want): 430\u00D7932 = 400\u202F760\n\t\t\t// Samsung Galaxy S22 Ultra with display size set to 80% (want):\n\t\t\t// 450\u00D7965 = 434\u202F250\n\t\t\t// Small tablet (don\u2019t want): 600\u00D7960 = 576\u202F000\n\t\t\t// Those number are virtual screen size, the viewport (used for\n\t\t\t// the check above) will be smaller with the browser\u2019s interface.\n\n\t\t\tconst isNavigatorConnectionSaveDataEnabled =\n\t\t\t\tnavigator.connection && navigator.connection.saveData;\n\t\t\tconst isNavigatorConnectionLike2g =\n\t\t\t\tnavigator.connection &&\n\t\t\t\tnavigator.connection.effectiveType &&\n\t\t\t\tnavigator.connection.effectiveType.includes('2g');\n\t\t\tconst isNavigatorConnectionAdequate =\n\t\t\t\t!isNavigatorConnectionSaveDataEnabled &&\n\t\t\t\t!isNavigatorConnectionLike2g;\n\n\t\t\tif (isOnSmallScreen && isNavigatorConnectionAdequate) {\n\t\t\t\tpreloadWhenVisible = true;\n\t\t\t}\n\t\t}\n\n\t\tif (intensityParameter == 'viewport-all') {\n\t\t\tpreloadWhenVisible = true;\n\t\t}\n\n\t\tconst intensityAsInteger = parseInt(intensityParameter);\n\t\tif (!isNaN(intensityAsInteger)) {\n\t\t\t_delayOnHover = intensityAsInteger;\n\t\t}\n\t}\n\n\tconst eventListenersOptions = {\n\t\tcapture: true,\n\t\tpassive: true,\n\t};\n\n\tif (preloadOnlyOnMousedown) {\n\t\tdocument.addEventListener(\n\t\t\t'touchstart',\n\t\t\ttouchstartEmptyListener,\n\t\t\teventListenersOptions\n\t\t);\n\t} else {\n\t\tdocument.addEventListener(\n\t\t\t'touchstart',\n\t\t\ttouchstartListener,\n\t\t\teventListenersOptions\n\t\t);\n\t}\n\n\tif (!preloadOnMousedown) {\n\t\tdocument.addEventListener(\n\t\t\t'mouseover',\n\t\t\tmouseoverListener,\n\t\t\teventListenersOptions\n\t\t);\n\t}\n\n\tif (preloadOnMousedown) {\n\t\tdocument.addEventListener(\n\t\t\t'mousedown',\n\t\t\tmousedownListener,\n\t\t\teventListenersOptions\n\t\t);\n\t}\n\tif (useMousedownShortcut) {\n\t\tdocument.addEventListener(\n\t\t\t'mousedown',\n\t\t\tmousedownShortcutListener,\n\t\t\teventListenersOptions\n\t\t);\n\t}\n\n\tif (preloadWhenVisible) {\n\t\tlet requestIdleCallbackOrFallback = window.requestIdleCallback;\n\t\t// Safari has no support as of 16.3: https://webkit.org/b/164193\n\t\tif (!requestIdleCallbackOrFallback) {\n\t\t\trequestIdleCallbackOrFallback = (callback) => {\n\t\t\t\tcallback();\n\t\t\t\t// A smarter fallback like setTimeout is not used because devices that\n\t\t\t\t// may eventually be eligible to a Safari version supporting prefetch\n\t\t\t\t// will be very powerful.\n\t\t\t\t// The weakest devices that could be eligible are the 2017 iPad and\n\t\t\t\t// the 2016 MacBook.\n\t\t\t};\n\t\t}\n\n\t\trequestIdleCallbackOrFallback(\n\t\t\tfunction observeIntersection() {\n\t\t\t\tconst intersectionObserver = new IntersectionObserver(\n\t\t\t\t\t(entries) => {\n\t\t\t\t\t\tentries.forEach((entry) => {\n\t\t\t\t\t\t\tif (entry.isIntersecting) {\n\t\t\t\t\t\t\t\tconst anchorElement = entry.target;\n\t\t\t\t\t\t\t\tintersectionObserver.unobserve(anchorElement);\n\t\t\t\t\t\t\t\tpreload(anchorElement.href);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tdocument.querySelectorAll('a').forEach((anchorElement) => {\n\t\t\t\t\tif (isPreloadable(anchorElement)) {\n\t\t\t\t\t\tintersectionObserver.observe(anchorElement);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t{\n\t\t\t\ttimeout: 1500,\n\t\t\t}\n\t\t);\n\t}\n}\n\nfunction touchstartListener(event) {\n\t_lastTouchstartEvent = event;\n\n\tconst anchorElement = event.target.closest('a');\n\n\tif (!isPreloadable(anchorElement)) {\n\t\treturn;\n\t}\n\n\tpreload(anchorElement.href, 'high');\n}\n\nfunction touchstartEmptyListener(event) {\n\t_lastTouchstartEvent = event;\n}\n\nfunction mouseoverListener(event) {\n\tif (isEventLikelyTriggeredByTouch(event)) {\n\t\t// This avoids uselessly adding a mouseout event listener and setting a timer.\n\t\treturn;\n\t}\n\n\tif (!('closest' in event.target)) {\n\t\treturn;\n\t\t// Without this check sometimes an error \u201Cevent.target.closest is not a function\u201D is thrown, for unknown reasons\n\t\t// That error denotes that `event.target` isn\u2019t undefined. My best guess is that it\u2019s the Document.\n\t\t//\n\t\t// Details could be gleaned from throwing such an error:\n\t\t//throw new TypeError(`instant.page non-element event target: timeStamp=${~~event.timeStamp}, type=${event.type}, typeof=${typeof event.target}, nodeType=${event.target.nodeType}, nodeName=${event.target.nodeName}, viewport=${innerWidth}x${innerHeight}, coords=${event.clientX}x${event.clientY}, scroll=${scrollX}x${scrollY}`)\n\t}\n\tconst anchorElement = event.target.closest('a');\n\n\tif (!isPreloadable(anchorElement)) {\n\t\treturn;\n\t}\n\n\tanchorElement.addEventListener('mouseout', mouseoutListener, {\n\t\tpassive: true,\n\t});\n\n\t_mouseoverTimer = setTimeout(() => {\n\t\tpreload(anchorElement.href, 'high');\n\t\t_mouseoverTimer = null;\n\t}, _delayOnHover);\n}\n\nfunction mousedownListener(event) {\n\tif (isEventLikelyTriggeredByTouch(event)) {\n\t\t// When preloading only on mousedown, not touch, we need to stop there\n\t\t// because touches send compatibility mouse events including mousedown.\n\t\t//\n\t\t// (When preloading on touchstart, instructions below this block would\n\t\t// have no effect.)\n\t\treturn;\n\t}\n\n\tconst anchorElement = event.target.closest('a');\n\n\tif (!isPreloadable(anchorElement)) {\n\t\treturn;\n\t}\n\n\tpreload(anchorElement.href, 'high');\n}\n\nfunction mouseoutListener(event) {\n\tif (\n\t\tevent.relatedTarget &&\n\t\tevent.target.closest('a') == event.relatedTarget.closest('a')\n\t) {\n\t\treturn;\n\t}\n\n\tif (_mouseoverTimer) {\n\t\tclearTimeout(_mouseoverTimer);\n\t\t_mouseoverTimer = null;\n\t}\n}\n\nfunction mousedownShortcutListener(event) {\n\tif (isEventLikelyTriggeredByTouch(event)) {\n\t\t// Due to a high potential for complications with this mousedown shortcut\n\t\t// combined with other parties\u2019 JavaScript code, we don\u2019t want it to run\n\t\t// at all on touch devices, even though mousedown and click are triggered\n\t\t// at almost the same time on touch.\n\t\treturn;\n\t}\n\n\tconst anchorElement = event.target.closest('a');\n\n\tif (event.which > 1 || event.metaKey || event.ctrlKey) {\n\t\treturn;\n\t}\n\n\tif (!anchorElement) {\n\t\treturn;\n\t}\n\n\tanchorElement.addEventListener(\n\t\t'click',\n\t\tfunction (event) {\n\t\t\tif (event.detail == 1337) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\t\t},\n\t\t{ capture: true, passive: false, once: true }\n\t);\n\n\tconst customEvent = new MouseEvent('click', {\n\t\tview: window,\n\t\tbubbles: true,\n\t\tcancelable: false,\n\t\tdetail: 1337,\n\t});\n\tanchorElement.dispatchEvent(customEvent);\n}\n\nfunction isEventLikelyTriggeredByTouch(event) {\n\t// Touch devices fire \u201Cmouseover\u201D and \u201Cmousedown\u201D (and other) events after\n\t// a touch for compatibility reasons.\n\t// This function checks if it\u2019s likely that we\u2019re dealing with such an event.\n\n\tif (!_lastTouchstartEvent || !event) {\n\t\treturn false;\n\t}\n\n\tif (event.target != _lastTouchstartEvent.target) {\n\t\treturn false;\n\t}\n\n\tconst now = event.timeStamp;\n\t// Chromium (tested Chrome 95 and 122 on Android) sometimes uses the same\n\t// event.timeStamp value in touchstart, mouseover, and mousedown.\n\t// Testable in test/extras/delay-not-considered-touch.html\n\t// This is okay for our purpose: two equivalent timestamps will be less\n\t// than the max duration, which means they\u2019re related events.\n\t// TODO: fill/find Chromium bug\n\tconst durationBetweenLastTouchstartAndNow =\n\t\tnow - _lastTouchstartEvent.timeStamp;\n\n\tconst MAX_DURATION_TO_BE_CONSIDERED_TRIGGERED_BY_TOUCHSTART = 2500;\n\t// How long after a touchstart event can a simulated mouseover/mousedown event fire?\n\t// /test/extras/delay-not-considered-touch.html tries to answer that question.\n\t// I saw up to 1450 ms on an overwhelmed Samsung Galaxy S2.\n\t// On the other hand, how soon can an unrelated mouseover event happen after an unrelated touchstart?\n\t// Meaning the user taps a link, then grabs their pointing device and clicks another/the same link.\n\t// That scenario could occur if a user taps a link, thinks it hasn\u2019t worked, and thus fall back to their pointing device.\n\t// I do that in about 1200 ms on a Chromebook. In which case this function returns a false positive.\n\t// False positives are okay, as this function is only used to decide to abort handling mouseover/mousedown/mousedownShortcut.\n\t// False negatives could lead to unforeseen state, particularly in mousedownShortcutListener.\n\n\treturn (\n\t\tdurationBetweenLastTouchstartAndNow <\n\t\tMAX_DURATION_TO_BE_CONSIDERED_TRIGGERED_BY_TOUCHSTART\n\t);\n\n\t// TODO: Investigate if pointer events could be used.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n\n\t// TODO: Investigate if InputDeviceCapabilities could be used to make it\n\t// less hacky on Chromium browsers.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/InputDeviceCapabilities_API\n\t// https://wicg.github.io/input-device-capabilities/\n\t// Needs careful reading of the spec and tests (notably, what happens with a\n\t// mouse connected to an Android or iOS smartphone?) to make sure it\u2019s solid.\n\t// Also need to judge if WebKit could implement it differently, as they\n\t// don\u2019t mind doing when a spec gives room to interpretation.\n\t// It seems to work well on Chrome on ChromeOS.\n\n\t// TODO: Consider using event screen position as another heuristic.\n}\n\nfunction isPreloadable(anchorElement) {\n\tif (!anchorElement || !anchorElement.href) {\n\t\treturn;\n\t}\n\n\tif (_useWhitelist && !('instant' in anchorElement.dataset)) {\n\t\treturn;\n\t}\n\n\tif (anchorElement.origin != location.origin) {\n\t\tlet allowed = _allowExternalLinks || 'instant' in anchorElement.dataset;\n\t\tif (!allowed || !_chromiumMajorVersionInUserAgent) {\n\t\t\t// Chromium-only: see comment on \u201Crestrictive prefetch\u201D and \u201Ccross-site speculation rules prefetch\u201D\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!['http:', 'https:'].includes(anchorElement.protocol)) {\n\t\treturn;\n\t}\n\n\tif (anchorElement.protocol == 'http:' && location.protocol == 'https:') {\n\t\treturn;\n\t}\n\n\tif (\n\t\t!_allowQueryString &&\n\t\tanchorElement.search &&\n\t\t!('instant' in anchorElement.dataset)\n\t) {\n\t\treturn;\n\t}\n\n\tif (\n\t\tanchorElement.hash &&\n\t\tanchorElement.pathname + anchorElement.search ==\n\t\t\tlocation.pathname + location.search\n\t) {\n\t\treturn;\n\t}\n\n\tif ('noInstant' in anchorElement.dataset) {\n\t\treturn;\n\t}\n\n\treturn true;\n}\n\nfunction preload(url, fetchPriority = 'auto') {\n\tif (_preloadedList.has(url)) {\n\t\treturn;\n\t}\n\n\tif (_speculationRulesType != 'none') {\n\t\tpreloadUsingSpeculationRules(url);\n\t} else {\n\t\tpreloadUsingLinkElement(url, fetchPriority);\n\t}\n\n\t_preloadedList.add(url);\n}\n\nfunction preloadUsingSpeculationRules(url) {\n\tconst scriptElement = document.createElement('script');\n\tscriptElement.type = 'speculationrules';\n\n\tscriptElement.textContent = JSON.stringify({\n\t\t[_speculationRulesType]: [\n\t\t\t{\n\t\t\t\tsource: 'list',\n\t\t\t\turls: [url],\n\t\t\t},\n\t\t],\n\t});\n\n\t// When using speculation rules, cross-site prefetch is supported, but will\n\t// only work if the user has no cookies for the destination site. The\n\t// prefetch will not be sent, if the user does have such cookies.\n\n\tdocument.head.appendChild(scriptElement);\n}\n\nfunction preloadUsingLinkElement(url, fetchPriority = 'auto') {\n\tconst linkElement = document.createElement('link');\n\tlinkElement.rel = 'prefetch';\n\tlinkElement.href = url;\n\n\tlinkElement.fetchPriority = fetchPriority;\n\t// By default, a prefetch is loaded with a low priority.\n\t// When there\u2019s a fair chance that this prefetch is going to be used in the\n\t// near term (= after a touch/mouse event), giving it a high priority helps\n\t// make the page load faster in case there are other resources loading.\n\t// Prioritizing it implicitly means deprioritizing every other resource\n\t// that\u2019s loading on the page. Due to HTML documents usually being much\n\t// smaller than other resources (notably images and JavaScript), and\n\t// prefetches happening once the initial page is sufficiently loaded,\n\t// this theft of bandwidth should rarely be detrimental.\n\n\tlinkElement.as = 'document';\n\t// as=document is Chromium-only and allows cross-origin prefetches to be\n\t// usable for navigation. They call it \u201Crestrictive prefetch\u201D and intend\n\t// to remove it: https://crbug.com/1352371\n\t//\n\t// This document from the Chrome team dated 2022-08-10\n\t// https://docs.google.com/document/d/1x232KJUIwIf-k08vpNfV85sVCRHkAxldfuIA5KOqi6M\n\t// claims (I haven\u2019t tested) that data- and battery-saver modes as well as\n\t// the setting to disable preloading do not disable restrictive prefetch,\n\t// unlike regular prefetch. That\u2019s good for prefetching on a touch/mouse\n\t// event, but might be bad when prefetching every link in the viewport.\n\n\tdocument.head.appendChild(linkElement);\n}\n"],
  "mappings": "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",
  "names": ["_chromiumMajorVersionInUserAgent", "_speculationRulesType", "_allowQueryString", "_allowExternalLinks", "_useWhitelist", "_delayOnHover", "_lastTouchstartEvent", "_mouseoverTimer", "_preloadedList", "init", "supportCheckRelList", "handleVaryAcceptHeader", "chromiumUserAgentIndex", "speculationRulesConfig", "useMousedownShortcut", "preloadOnMousedown", "preloadOnlyOnMousedown", "preloadWhenVisible", "intensityParameter", "isOnSmallScreen", "isNavigatorConnectionSaveDataEnabled", "isNavigatorConnectionLike2g", "intensityAsInteger", "eventListenersOptions", "touchstartEmptyListener", "touchstartListener", "mouseoverListener", "mousedownListener", "mousedownShortcutListener", "requestIdleCallbackOrFallback", "callback", "intersectionObserver", "entries", "entry", "anchorElement", "preload", "isPreloadable", "event", "isEventLikelyTriggeredByTouch", "mouseoutListener", "customEvent", "url", "fetchPriority", "preloadUsingSpeculationRules", "preloadUsingLinkElement", "scriptElement", "linkElement"]
}
